import p2pmud.P2PMudPeerimport p2pmud.P2PMudCommandHandlerimport java.awt.Dimensionimport java.awt.Componentimport javax.swing.BoxLayoutimport javax.swing.border.LineBorderimport javax.swing.SpringLayoutimport java.awt.GridBagLayoutimport java.awt.GridBagConstraintsimport java.awt.GridBagConstraintsimport javax.swing.BoxLayoutimport java.awt.BorderLayoutimport static java.awt.BorderLayout.*import static java.awt.GridBagConstraints.*import java.awt.*import javax.swing.*import javax.swing.border.*import groovy.swing.SwingBuilderimport net.miginfocom.swing.MigLayoutif (args.length < 2) {	println "Usage: Test port name pastryArgs"	System.exit(1);}output = nullpendingCommands = [:]name = args[1]names = [p0: name]count = 0//sauerCmds = new SauerCmds(this)sauerCmds = [:]pastryCmds = [:]def sauer(key, value) {	synchronized (pendingCommands) {		pendingCommands[key] = value	}}def runCommand(str, cmds) {	def args = str.split()	def func = cmds[args[0]]	println "EXECUTING: $args"	if (func) {		func(args.length > 1 ? args[1..-1] : [])	}//	cmds.invokeMethod(args[0], args[1..-1])}def start() {	sock = new ServerSocket(Integer.parseInt(args[0]))	println "READY"	while (true) {		Socket client = sock.accept({			println("Got connection...")			output = it.getOutputStream()			init()			it.getInputStream().eachLine {//				println "RECEIVED: $it"				runCommand(it, sauerCmds)				dumpCommands()			}			try {it.shutdownInput()} catch (Exception ex) {}			try {it.shutdownOutput()} catch (Exception ex) {}			println "Disconnect"		});	}}def dumpCommands() {	if (output) {		synchronized (pendingCommands) {			if (!pendingCommands.isEmpty()) {				output << pendingCommands.collect{it.value}.join(";") + '\n'				println "SENT: ${pendingCommands.collect{it.value}.join(';') + '\n'}"				pendingCommands = [:]			}		}		output.flush()	}}def sauerEnt(label, field) {	if (field.text && field.text[0]) {		def cmd = "ent.$label p0 ${field.text}"		println "NEW $label: $cmd"		sauer(label, cmd)		dumpCommands()	}}def newX() {	sauerEnt('x', xField)}def newY() {	sauerEnt('y', yField)}def newZ() {	sauerEnt('z', zField)}def cmd() {	if (cmdField.text && cmdField.text[0]) {		sauer('cmd', cmdField.text)		cmdField.text = ""		dumpCommands()	}}swing = new SwingBuilder()swing.build {	f = frame(title: 'Position', windowClosing: {System.exit(0)}, layout: new MigLayout('fillx'), pack: true, show: true) {		label(name: 'xLabel', text: "x: ")		xField = textField(name: 'xField', actionPerformed: {newX()}, focusLost: {newX()}, constraints: 'wrap, growx')		label(name: 'yLabel', text: "y: ")		yField = textField(name: 'yField', actionPerformed: {newY()}, focusLost: {newY()}, constraints: 'wrap, growx')		label(name: 'zLabel', text: "z: ")		zField = textField(name: 'zField', actionPerformed: {newZ()}, focusLost: {newZ()}, constraints: 'wrap, growx')		label(name: 'cmdLabel', text: "Command: ")		cmdField = textField(name: 'cmdField', actionPerformed: {cmd()}, focusLost: {cmd()}, constraints: 'wrap, growx')	}	f.size = [500, (int)f.size.height] as Dimension}sauerCmds.position = {args ->	if (names[args[0]] == name) {		swing.edt {			xField.text = args[1]			yField.text = args[2]			zField.text = args[3]		}		println "SENDING: update ${args[1..-1].join(' ')}"		pastry(["update $name ${args[1..-1].join(' ')}"])	}}sauerCmds.login = {args ->	pastry([		"login $name ${args.join(' ')}"	])}sauerCmds.chat = {args ->	pastry([		"chat ${args.join(' ')}"	])}pastryCmds.login = {args ->	sauer('echo', "echo ${args[0]} has joined!")	pastryCmds.update(args)}pastryCmds.update = {args ->	sauer('m0.x', "ent.x m0 ${args[1]}")	sauer('m0.y', "ent.y m0 ${args[2]}")	sauer('m0.z', "ent.z m0 ${args[3]}")	sauer('m0.roll', "ent.roll m0 ${args[4]}")	sauer('m0.pitch', "ent.pitch m0 ${args[5]}")	sauer('m0.yaw', "ent.yaw m0 ${args[6]}")	dumpCommands()}pastryCmds.sauer = {args ->	for (i = 0; i < args.size(); i++) {		sauer(i, args.join(" "))	}	dumpCommands()}pastryCmds.chat = {args ->	sauer('chat', "psay m0 [${args.join(' ')}]")	dumpCommands()}def init() {	sauer('init', 'alias chat [remotesend chat $arg1];bind j [saycommand "/chat "];editbind j [saycommand "/chat "];echo INIT')	dumpCommands()}def pastry(cmds) {	P2PMudPeer.test.sendCmds(cmds as String[])}new Thread({start()}).start()//pastryArgs = ['9090', '-', '9090', '-external', '75.13.72.30:9090']//pastryArgs = ['9090', '-', '9090']P2PMudPeer.main({cmd -> cmd.msgs.each {runCommand(it, pastryCmds)}} as P2PMudCommandHandler, args[2..-1] as String[])