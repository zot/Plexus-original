## all commands in a default sauer (12/24 assassin version)

command: addserver(s)
command: alias(ss)
command: altshader(ss)
command: approve(s)
command: at(si)
command: attachent()
command: attack(D)
command: autograss(s)
command: backward(D)
command: bind(ss)
command: brushvert(iii)
command: calclight(i)
command: cancelsel()
command: clearbans()
command: clearbrush()
command: cleardemos(i)
command: cleargui(i)
command: clearsleep(i)
command: complete(sss)
command: concat(C)
command: concatword(V)
command: connect(s)
command: conskip(i)
command: copy()
command: cubecancel()
command: delcube()
command: delent()
command: disconnect()
command: div(ii)
command: dropent()
command: dumplms()
command: echo(C)
command: editbind(ss)
command: editface(ii)
command: editmat(s)
command: edittex(i)
command: edittoggle()
command: entautoview(i)
command: entcancel()
command: entcopy()
command: entflip()
command: entget()
command: enthavesel()
command: entloop(s)
command: entpaste()
command: entpush(i)
command: entrotate(i)
command: entselect(s)
command: entset(siiii)
command: exec(s)
command: fastshader(ssi)
command: flip()
command: flipnormalmapy(ss)
command: follow(s)
command: fontchar(iiii)
command: font(ssiiiiii)
command: format(V)
command: forward(D)
command: getalias(s)
command: getbind(s)
command: getdemo(i)
command: geteditbind(s)
command: getmap()
command: getname()
command: getteam()
command: gettex()
command: goto(s)
command: guibar()
command: guibutton(sss)
command: guicheckbox(ssiis)
command: guifield(siss)
command: guiimage(ssfis)
command: guilist(s)
command: guilistslider(sss)
command: guiradio(ssis)
command: guiservers(s)
command: guislider(siis)
command: guistayopen(s)
command: guitab(s)
command: guitext(ss)
command: guititle(s)
command: havesel()
command: history(i)
command: hmapcancel()
command: hmapselect()
command: !(i)
command: if(sss)
command: ^(ii)
command: <=(ii)
command: <(ii)
command: =(ii)
command: >=(ii)
command: >(ii)
command: -(ii)
command: !=(ii)
command: *(ii)
command: +(ii)
command: importcube(s)
command: insel()
command: isshaderdefined(s)
command: isshadernative(s)
command: jump(D)
command: keymap(ss)
command: kick(s)
command: kill()
command: lanconnect()
command: lavacolour(iii)
command: left(D)
command: listcomplete(ss)
command: listdemos()
command: listidents()
command: listlen(s)
command: loadcrosshair(s)
command: loadsky(sf)
command: loop(sis)
command: mapenlarge()
command: mapmodel(iiiss)
command: mapmodelreset()
command: mapmsg(s)
command: mapname()
command: map(s)
command: mapsound(sii)
command: mastermode(i)
command: materialreset()
command: max(ii)
command: md2anim(siifi)
command: md2pitch(ffff)
command: md3alphablend(si)
command: md3alphatest(sf)
command: md3ambient(si)
command: md3anim(siifi)
command: md3bumpmap(sss)
command: md3envmap(ss)
command: md3fullbright(sf)
command: md3glow(si)
command: md3link(iis)
command: md3load(s)
command: md3pitch(ffff)
command: md3scroll(sff)
command: md3shader(ss)
command: md3skin(sssff)
command: md3spec(si)
command: md3translucent(sf)
command: mdlalphablend(i)
command: mdlalphatest(f)
command: mdlambient(i)
command: mdlbb(fff)
command: mdlcollide(i)
command: mdlcullface(i)
command: mdlellipsecollide(i)
command: mdlenvmap(iis)
command: mdlfullbright(f)
command: mdlglow(i)
command: mdlname()
command: mdlscale(i)
command: mdlshader(s)
command: mdlshadow(i)
command: mdlspec(i)
command: mdlspin(f)
command: mdltrans(fff)
command: mdltranslucent(f)
command: mergenormalmaps(sss)
command: min(ii)
command: mmodel(si)
command: mode(i)
command: mod(ii)
command: music(ss)
command: name(s)
command: newent(siiii)
command: newgui(ss)
command: newmap(i)
command: nextweapon(i)
command: onrelease(s)
command: paste()
command: pastehilite()
command: patchlight(i)
command: phystest()
command: platform(ii)
command: pop(s)
command: printcube()
command: pushsel(i)
command: push(ss)
command: quit()
command: recalc()
command: recorddemo(i)
command: redo()
command: registersound(si)
command: remip()
command: remoteallow(si)
command: remoteconnect()
command: remotedisable()
command: remotedisconnect(s)
command: remotesend(V)
command: reorient()
command: repammo()
command: replace()
command: result(s)
command: right(D)
command: rnd(i)
command: rotate(i)
command: savecurrentmap()
command: savemap(s)
command: say(C)
command: saycommand(C)
command: screenres(ii)
command: screenshot(s)
command: selextend()
command: sendmap()
command: setfullscreenshader(siiii)
command: setmaster(s)
command: setpixelparam(iffff)
command: setshader(s)
command: setteam(ss)
command: setuniformparam(sffff)
command: setvertexparam(iffff)
command: setweapon(i)
command: shader(isss)
command: showgui(s)
command: showscores(D)
command: showtexgui(i)
command: skylight(sss)
command: sleep(is)
command: sound(i)
command: spectator(is)
command: ||(ss)
command: &&(ss)
command: stopdemo()
command: strcmp(ss)
command: strstr(ss)
command: taunt()
command: team(s)
command: texturereset()
command: texture(ssiiif)
command: toggleconsole()
command: trigger(ii)
command: undo()
command: updatefrommaster()
command: watercolour(iii)
command: weapon(sss)
command: while(ss)
command: writecfg()
command: writeobj(s)
var: aaenvmap 2
var: adaptivesample 1
var: allfaces 0
var: ambient 25
var: animationinterpolationtime 150
var: animoverride 0
var: aniso 0
var: apple_ff_bug 0
var: apple_glsldepth_bug 0
var: apple_minmax_bug 0
var: ati_oq_bug 0
var: ati_skybox_bug 0
var: ati_texgen_bug 0
var: attachradius 100
var: bilinear 1
var: blood 1
var: blurlms 0
var: blurshadowmap 1
var: blurskylight 0
var: blursmsigma 100
var: blurtile 1
var: bounddynshadows 1
var: brushx 32
var: brushy 32
var: bumperror 3
var: bumpmodels 1
var: bypassheightmapcheck 0
var: causticmillis 75
var: caustics 1
var: causticscale 100
var: clockerror 1000000
var: clockfix 0
var: colorbits 0
var: consize 5
var: convertlms 1
var: crosshairfx 1
var: crosshairsize 15
var: cursorsize 30
var: damageblendfactor 300
var: debugsm 0
var: decalfade 10000
var: depthbits 0
var: dragging 0
var: dtoutline 0
var: dynentsize 8
var: dynlightdist 1024
var: dynshadow 60
var: edgetolerance 4
var: editing 0
var: emitfps 60
var: emulatefog 0
var: entautoviewdist 25
var: entdrop 2
var: entediting 0
var: entitysurf 0
var: entmoving 0
var: entmovingshadow 1
var: entselradius 2
var: entselsnap 0
var: envmapmodels 1
var: envmapradius 128
var: envmapsize 7
var: explosion2d 0
var: flarecutoff 1000
var: flarelights 0
var: flaresize 100
var: floatspeed 100
var: floatvtx 0
var: fog 4000
var: fogcolour 8427955
var: followdist 50
var: followorient 1
var: fov 105
var: fpshadowmap 0
var: fsaa 0
var: fullbright 0
var: fullscreen 0
var: gamespeed 100
var: gamma 100
var: glassenv 1
var: glowmodels 1
var: glowpass 1
var: grass 1
var: grassanimdist 500
var: grassbbcorrect 1
var: grassbillboard 1
var: grassblend 0
var: grassdist 500
var: grassfalloff 100
var: grassgrid 6
var: grassheight 8
var: grasslod 25
var: grasslodz 150
var: grassrand 30
var: grasssamples 50
var: grasstaper 200
var: grasstest 0
var: grasswidth 6
var: gridlookup 0
var: gridpower 3
var: gui2d 0
var: guiautotab 16
var: hidehud 0
var: hidestats 0
var: highlightscore 1
var: hmapedit 0
var: hudgun 1
var: hudgunfov 65
var: hudgunsway 1
var: hwcubetexsize 0
var: hwmaxaniso 0
var: hwtexsize 0
var: importcuberemip 1024
var: intel_quadric_bug 0
var: invalidcubeguard 1
var: invmouse 0
var: lavafog 50
var: lerpangle 44
var: lerpsubdiv 2
var: lerpsubdivsize 4
var: lightcachesize 8
var: lightcompress 3
var: lighterror 8
var: lightlod 0
var: lightmodels 1
var: lightprecision 32
var: lnjittermillis 100
var: lnjitterradius 2
var: loddistance 2000
var: lodsize 32
var: maskreflect 2
var: maxbarreldebris 10
var: maxdebris 25
var: maxdynlights 5
var: maxfps 200
var: maxmerge 8
var: maxmodelradiusdistance 100
var: maxparticledistance 512
var: maxradarscale 1024
var: maxreflect 1
var: maxroll 3
var: maxsoundsatonce 5
var: maxtexsize 0
var: maxtmus 0
var: menuautoclose 120
var: menudistance 40
var: mesa_dre_bug 0
var: minface 1
var: minframetime 10
var: minimizetcusage 0
var: mipvis 0
var: mmskylight 1
var: moving 0
var: musicvol 128
var: nativeshaders 1
var: nolights 0
var: nomasks 0
var: nowater 0
var: numargs 0
var: nvidia_texgen_bug 0
var: octaentsize 128
var: ogro 0
var: optmats 1
var: oqdist 256
var: oqdynent 1
var: oqfrags 8
var: oqmm 4
var: oqreflect 4
var: oqwater 1
var: orientinterpolationtime 75
var: outline 0
var: outlinemeters 0
var: particlesize 100
var: particletext 1
var: passthroughcube 1
var: passthroughsel 0
var: patchnormals 0
var: paused 0
var: printvbo 0
var: rate 0
var: reflectclip 6
var: reflectdist 2000
var: reflectmms 1
var: reflectsize 8
var: refractfog 1
var: reservedynlighttc 0
var: reserveshadowmaptc 0
var: savebak 2
var: scr_h 768
var: scr_w 1024
var: selectcorners 0
var: selectionsurf 0
var: sensitivity 3
var: sensitivityscale 1
var: shaderdetail 3
var: shaderprecision 0
var: shaders -1
var: shadowmap 0
var: shadowmapambient 0
var: shadowmapangle 0
var: shadowmapbias 5
var: shadowmapcasters 0
var: shadowmapdist 256
var: shadowmapheight 32
var: shadowmappeelbias 20
var: shadowmapprecision 0
var: shadowmapradius 96
var: shadowmapsize 9
var: showboundingbox 0
var: showclientnum 0
var: showconnecting 0
var: showcstats 0
var: showentradius 1
var: showfpsrange 0
var: showmat 1
var: showping 1
var: showpj 1
var: showsky 1
var: showspectators 1
var: skill 3
var: smdepthpeel 1
var: smscissor 1
var: soundbufferlen 1024
var: soundchans 32
var: soundfreq 22050
var: soundvol 255
var: sparklyfix 1
var: stencilbits 1
var: stereo 1
var: teamhudguns 1
var: teamskins 0
var: testanims 0
var: texcompress 1024
var: texreduce 0
var: thirdperson 0
var: thirdpersondistance 50
var: throttle_accel 2
var: throttle_decel 2
var: throttle_interval 5
var: thumbtime 50
var: triggerstate 0
var: trilinear 1
var: undomegs 5
var: vacubemax 2048
var: vacubemin 128
var: vacubesize 128
var: vbosize 0
var: vertwater 1
var: vsync -1
var: waterfade 1
var: waterfog 150
var: waterlod 1
var: waterreflect 1
var: waterrefract 1
var: waterspec 150
var: watersubdiv 2
var: wireframe 0
var: worldlod 0
var: zpass 1
alias: a0 = [272]
alias: a = [1]
alias: a1 = [2]
alias: a2 = [0]
alias: a3 = [0]
alias: actions = [forward backward left right jump attack "saycommand   " "universaldelta 1" "universaldelta -1" edittoggle "weapon 1" "weapon 2" "weapon 3" "weapon 4"]
alias: aiclip = [ editmat aiclip ]
alias: air = [ editmat air ]
alias: aliasname = [bestscore_rpg]
alias: arg1 = []
alias: arg2 = []
alias: arg3 = []
alias: arg4 = []
alias: arg5 = []
alias: asn = [ mode 15; map $arg1 ]
alias: bindit = [ bind $arg1 $tobind ]
alias: bindmod = [
  bind $arg1 [@arg2 1; onrelease [@@arg2 0]]
]
alias: bindvar = [
  bind $arg1 [@arg2 (= $@arg2 0); if (= $@arg2 0) [echo @@arg2 OFF] [ echo @@arg2 ON]]
]
alias: bloomshader = [
    shader 0 (concatword $arg1 "_scale") [ @fsvs @setup4corners END ] [
        @fsps
        @sample4corners
        TEMP t;
        ADD t, s02, s00;
        ADD t, t, s22;
        ADD t, t, s20;
        ADD t, t, sample;
        MUL result.color, t, 0.2; 
        END
    ]

    shader 0 (concatword $arg1 "_init") [ @fsvs END ] [
        @fsps
        TEMP t;
        MAX t, sample.r, sample.g;
        MAX t, t, sample.b;
        MUL t, t, t;
        MUL result.color, t, sample;
        END
    ]

    shader 0 $arg1 [
        @fsvs
        TEMP tc;
        MOV tc, vertex.texcoord[0];
        @(loopconcat i (- $arg2 1) [concat "MUL tc, tc, 0.5; MOV result.texcoord[" (+ $i 1) "], tc;"])
        END
    ] [
        @fsps
        TEMP scaled, bloom;
        @(loopconcat i (- $arg2 1) [
            format [
                TEX @(if (> $i 0) [result "scaled"] [result "bloom"]), fragment.texcoord[%1], texture[%1], RECT;
                @(if (> $i 0) [result [
                    ADD bloom, bloom, scaled;
                ]])
            ] (+ $i 1)
        ])
        MAD result.color, bloom, program.env[0].x, sample;
        END
    ]
]
alias: blurshader = [
    shader 0 $arg1 [
        !!ARBvp1.0
        MOV result.position, vertex.position;
        MOV result.texcoord[0], vertex.texcoord[0];
        END 
    ] [
        @fpstart
        TEMP val, blur1, blur2, tc1, tc2;
        TEX val, fragment.texcoord[0], texture[0], 2D;
        MUL val, val, program.env[0].x;
        @(loopconcat i $arg2 [concatword [
            @(if (= $i 0) [result [
                ADD tc1.xy, fragment.texcoord[0], program.env[1];
                SUB tc2.xy, fragment.texcoord[0], program.env[1];
            ]] [result [
                ADD tc1.@@@@arg3, tc1, program.env[1].@(at "z w" (- $i 1));
                SUB tc2.@@@@arg3, tc2, program.env[1].@(at "z w" (- $i 1));
            ]])
            TEX blur1, tc1, texture[0], 2D;
            TEX blur2, tc2, texture[0], 2D;
            ADD blur1, blur1, blur2;
            MAD @(if (= (+ $i 1) $arg2) [result "result.color"] [result "val"]), blur1, program.env[0].@(at "y z w" $i), val;
        ]])
        END
    ]
]
alias: brush_0 = [
      brushname = [Circle 1-0 Brush]
      clearbrush
      brushhandle 0 0; brushverts [1]
    ]
alias: brush_1 = [
      brushname = [Circle 2-1 Brush]
      clearbrush
      brushhandle 2 2; brushverts [
    ""
    "0 0 1 "
    "0 1 2 1 "
    "0 0 1 "
]
    ]
alias: brush_2 = [
      brushname = [Circle 4-2-1 Brush]
      clearbrush
      brushhandle 2 2; brushverts [
  "0 0 1 "
  "0 1 2 1 "
  "1 2 4 2 1 "
  "0 1 2 1 "
  "0 0 1 "
]
    ]
alias: brush_3 = [
      brushname = [Square 3x3 brush]
      clearbrush
      brushhandle 1 1; brushverts [
  "1 1 1 "
  "1 1 1 "
  "1 1 1 "
]
    ]
alias: brush_4 = [
      brushname = [Square 5x5 brush]
      clearbrush
      brushhandle 2 2; brushverts [
  "1 1 1 1 1 "
  "1 1 1 1 1 "
  "1 1 1 1 1 "
  "1 1 1 1 1 "
  "1 1 1 1 1 "
]
    ]
alias: brush_5 = [
      brushname = [Square 7x7 brush]
      clearbrush
      brushhandle 3 3; brushverts [
  "1 1 1 1 1 1 1 "
  "1 1 1 1 1 1 1 "
  "1 1 1 1 1 1 1 "
  "1 1 1 1 1 1 1 "
  "1 1 1 1 1 1 1 "
  "1 1 1 1 1 1 1 "
  "1 1 1 1 1 1 1 "
]
    ]
alias: brush_6 = [
      brushname = [Smooth 3x3 brush]
      clearbrush
      brushhandle 1 1; brushverts [
  "0 0 0 "
  "0 "
  "0 "
]
    ]
alias: brush_7 = [
      brushname = [Smooth 5x5 brush]
      clearbrush
      brushhandle 2 2; brushverts [
  "0 0 0 0 0 "
  "0 "
  "0 "
  "0 "
  "0 "
]
    ]
alias: brush_8 = [
      brushname = [Smooth 7x7 brush]
      clearbrush
      brushhandle 3 3; brushverts [
  "0 0 0 0 0 0 0"
  "0 "
  "0 "
  "0 "
  "0 "
  "0 "
  "0 "
]
    ]
alias: brush_9 = [
      brushname = [Noise 25x25 Brush]
      clearbrush
      brushhandle 12 12; brushverts [
  "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 "
  ""
  "0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 1 "
  "0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 2 2 "
  "0 0 0 0 1 1 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 "
  "0 0 0 0 0 1 0 0 0 0 0 2 0 0 0 0 1 0 0 0 1 1 0 0 1 "
  "0 0 1 0 0 0 1 0 1 1 0 0 0 0 1 0 0 1 0 0 0 0 2 "
  "0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 1 1 1 2 "
  "0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 1 "
  "0 0 0 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 1 0 1 "
  "0 1 0 2 0 1 1 1 1 0 0 1 0 0 0 0 1 "
  "0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 "
  "1 0 1 0 0 0 0 0 1 0 0 0 1 0 1 "
  "0 0 0 0 0 0 0 1 1 0 1 1 0 0 1 0 0 1 0 0 0 0 1 0 0 1 "
  "0 1 1 1 0 3 0 2 0 0 0 1 1 0 0 0 1 1 "
  "0 0 1 0 0 1 0 0 1 0 1 1 0 1 0 0 0 0 0 1 "
  "0 0 1 1 0 0 0 0 2 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 1 "
  "0 1 1 0 1 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 0 1 "
  "1 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 1 "
  "0 0 0 1 0 0 1 0 1 1 0 0 0 0 0 0 0 1 "
  "0 0 0 0 0 0 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 1 "
  "0 0 0 0 1 0 1 1 0 2 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 "
  "0 0 0 0 0 0 0 0 0 1 0 1 "
  "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 "
]
    ]
alias: brushcopy = [0]
alias: brushhandle = [
  brushx $arg1
  brushy $arg2
]
alias: brushindex = [3]
alias: brushmax = [9]
alias: brushname = [Square 3x3 brush]
alias: brushverts = [
  loop y (listlen $arg1) [
    bv = (at $arg1 $y)
    loop x (listlen $bv) [
      brushvert $x $y (at $bv $x)
    ]
  ]
]
alias: btopt = [ >= (strstr $bumptype $arg1) 0 ]
alias: build_trigger = [newent mapmodel $BTmm $BTtt $BTti]
alias: bumpshader = [
    bumptype = $arg2
    normtex = (if (btopt "e") [result "texture[4]"] [result "texture[3]"])
    glowtex = (if (btopt "e") [result "texture[5]"] [result "texture[4]"])
    if (btopt "G") [
        setvertexparam 0 1 1 1 
        setvertexparam 4 1     
        setvertexparam 5 0 0 0 
    ] [if (btopt "g") [
        setpixelparam 0 1 1 1  
    ]]
    if (btopt "S") [
        setpixelparam 1 6 6 6 
    ] [if (btopt "s") [
        setpixelparam 1 1 1 1 
    ]]
    if (|| (btopt "p") (btopt "P")) [
        setpixelparam 2 0.06 -0.03 
    ]
    if (btopt "R") [
        setpixelparam 3 1 1 1 
    ] [if (btopt "r") [
        setpixelparam 3 0.2 0.2 0.2 
    ]]
    shader (if (btopt "e") [result 3] [result 1]) $arg1 [
        @vpstart
        DP3 result.texcoord[0].x, opos, program.env[0];
        DP3 result.texcoord[0].y, opos, program.env[1];
        
        
        DP3 @(if (|| $minimizetcusage (btopt "r")) [result "result.texcoord[0].z"] [result "result.texcoord[1].x"]), state.matrix.texture[1].row[0], vertex.texcoord[1];
        DP3 @(if (|| $minimizetcusage (btopt "r")) [result "result.texcoord[0].w"] [result "result.texcoord[1].y"]), state.matrix.texture[1].row[1], vertex.texcoord[1];
        @fogcoord
        
        @(if (btopt "o") [result [
            TEMP camv, normal, tangent, binormal, x, y;
            MAD normal, vertex.color, 2, -1;
        
            
            DP3 x, normal, program.env[2];
            MUL x, x, normal;
            SUB tangent, program.env[2], x;
            DP3 x, tangent, program.env[3];
            MUL x, x, tangent;
            DP3 y, normal, program.env[3];
            MUL y, y, normal;
            SUB binormal, program.env[3], x;
            SUB binormal, binormal, y;
        
            @@(if (btopt "t") [result [
                
                SUB camv, program.env[4], opos;
                DP3 @(if (btopt "r") [result "result.texcoord[1].x"] [result "result.texcoord[2].x"]), camv, tangent;
                DP3 @(if (btopt "r") [result "result.texcoord[1].y"] [result "result.texcoord[2].y"]), camv, binormal;
                DP3 @(if (btopt "r") [result "result.texcoord[1].z"] [result "result.texcoord[2].z"]), camv, normal;
            ]])
            @@(if (btopt "r") [result [
                @@(if (! (btopt "t")) [result [
                    SUB camv, program.env[4], opos;
                    MOV camv.y, -camv;
                    MOV result.texcoord[1], camv.yzxw;
                ]])

                
                MOV result.texcoord[2].x, -tangent.y;
                MOV result.texcoord[2].y, -binormal.y;
                MOV result.texcoord[2].z, -normal.y;

                MOV result.texcoord[3].x, tangent.z;
                MOV result.texcoord[3].y, binormal.z;
                MOV result.texcoord[3].z, normal.z;

                MOV result.texcoord[4].x, tangent.x;
                MOV result.texcoord[4].y, binormal.x;
                MOV result.texcoord[4].z, normal.x;
            ]])
        ]])

        @(if (btopt "G") [result [
            TEMP pulse, pulsecol;
            MUL pulse, program.env[5], @vertexparam4.x;
            FRC pulse, pulse;
            MAD pulse, pulse, 2, -1;
            ABS pulse, pulse;
            SUB pulsecol, @vertexparam5, @vertexparam0; 
            MAD result.texcoord[2].w, pulse, pulsecol, @vertexparam0;
        ]])

        #pragma CUBE2_shadowmap
        #pragma CUBE2_dynlight

        END
    ] [
        @fpstart
        OPTION ARB_fog_linear;
        ATTRIB @(if (|| (btopt "p") (btopt "P")) [result "htc"] [result "dtc"]) = fragment.texcoord[0];
        ATTRIB lmtc = @(if (|| $minimizetcusage (btopt "r")) [result "fragment.texcoord[0]"] [result "fragment.texcoord[1]"]);
        @(if (btopt "r") [result [
            ATTRIB cam = fragment.texcoord[1];
        ]] [if (btopt "t") [result [
            ATTRIB cam = fragment.texcoord[2];
        ]]]) 
        TEMP diffuse, lmc, lmlv, bump, light;

        TEX lmc,  @(if (|| $minimizetcusage (btopt "r")) [result "lmtc.zwzw"] [result "lmtc"]), texture[1], 2D;
        TEX lmlv, @(if (|| $minimizetcusage (btopt "r")) [result "lmtc.zwzw"] [result "lmtc"]), texture[2], 2D;
        MAD lmlv, lmlv, 2, -1;    
    
        @(if (btopt "t") [result [
            TEMP camvts;
            @(normalize camvts cam)
        ]])

        @(if (btopt "p") [result [
            TEMP height;
            TEX height, htc, @@normtex, 2D;
            MAD height.w, height.w, @pixelparam2.x, @pixelparam2.y;    
            TEMP dtc;
            MAD dtc, height.w, camvts, htc;
        ]])

        @(if (btopt "P") [result [
            PARAM step = -0.142857142857143; 
            TEMP duv, dtc, cc;
            RCP duv, camvts.z;
            MUL duv, duv, camvts;
            MUL duv, duv, step;
            MUL duv.xy, duv, @pixelparam2.x;

            MAD dtc.xy, duv, @pixelparam2.y, htc;
            MOV dtc.z, 1.0;
            TEX bump, dtc, @@normtex, 2D; 

            @@(loopconcat i 7 [concatword [
                SLT cc, bump.w, dtc.z;
                MAD dtc, duv, cc, dtc;
                TEX bump, dtc, @@normtex, 2D;
            ]])
        ]])

        TEX diffuse, dtc, texture[0], 2D;
        MUL diffuse, diffuse, 2;

        @(if (! (btopt "P")) [result [TEX bump, dtc, @normtex, 2D;]])
        MAD bump.xyz, bump, 2, -1;

        @(if (btopt "s") [result [
            PARAM specfactor = 32;
            TEMP he;
            ADD he, camvts, lmlv;
            @(normalize he he)
            DP3_SAT he.w, he, bump;
            POW he.w, he.w, specfactor.x;
            @(if (btopt "S") [result [MUL he.w, he, diffuse;]])
            MAD diffuse.xyz, he.w, @pixelparam1, diffuse;
        ]])

        DP3_SAT light, bump, lmlv;
        MUL light, light, lmc;
        MAX light, light, program.env[5];

        #pragma CUBE2_shadowmap light
        #pragma CUBE2_dynlight light

        MUL @(if (|| (btopt "g") (btopt "r")) [result "diffuse.rgb"] [result "result.color"]), diffuse, light;

        @(if (btopt "r") [result [
            TEMP rvec;
            @(if (btopt "t") [result [
                TEMP rvects;
                DP3 rvects, cam, bump;
                MUL rvects, rvects, bump; 
                MAD rvects, rvects, 2, -cam; 

                DP3 rvec.x, rvects, fragment.texcoord[2];
                DP3 rvec.y, rvects, fragment.texcoord[3];
                DP3 rvec.z, rvects, fragment.texcoord[4];
            ]] [result [
                TEMP bumpw;
                DP3 bumpw.x, bump, fragment.texcoord[2];
                DP3 bumpw.y, bump, fragment.texcoord[3];
                DP3 bumpw.z, bump, fragment.texcoord[4];

                DP3 rvec, cam, bumpw;
                MUL rvec, rvec, bumpw; 
                MAD rvec, rvec, 2, -cam; 
            ]])

            TEMP reflect;
            TEX reflect, rvec, texture[3], CUBE;
            @@(if (btopt "R") [result [
                TEMP rmod;
                MUL rmod, diffuse.w, @pixelparam3;
            ]] [result [
                PARAM rmod = @pixelparam3;
            ]])
            LRP @(if (btopt "g") [result "diffuse.rgb"] [result "result.color"]), rmod, reflect, diffuse;
        ]])

        @(if (btopt "g") [result [
            TEMP glow;
            TEX glow, dtc, @@glowtex, 2D;
            MAD result.color, glow, @@(if (btopt "G") [result "fragment.texcoord[2].w"] [result $pixelparam0]), diffuse;
        ]])

        #pragma CUBE2_water

        END
    ]
]
alias: bumptype = [epotsSrRgG]
alias: bv = [1 1 1 ]
alias: cancelpaste = [0]
alias: capturemaps1 = [river_c paradigm fb_capture urban_c serenity nevil_c lostinspace face-capture nmp9 c_valley nmp4 nmp8_c fc3 ph-capture monastery corruption hades]
alias: capturemaps2 = [asteroids venice relic frostbyte ogrosupply]
alias: capture = [ mode 12; map $arg1 ]
alias: causticshader = [
    shader 0 $arg1 [
        @vpstart
        DP3 result.texcoord[0].x, opos, state.texgen.object.s;
        DP3 result.texcoord[0].y, opos, state.texgen.object.t;
        @fogcoord
        END
    ] [
        @fpstart
        OPTION ARB_fog_linear;
        @arg2
        END
    ]
]
alias: clearents = [ 
  if $editing [
    entcancel
    entselect [ strcmp (et) $arg1 ]; 
    echo Deleted (enthavesel) $arg1 entities; 
    delent
  ] 
]
alias: clip = [ editmat clip ]
alias: cmd = [newent mapmodel 100]
alias: combine = [ 
    DP3_SAT invfresnel, cam, bump;
    MAD invfresnel, invfresnel, 0.5, 0.5;
    LRP result.color.rgb, invfresnel, refract, reflect;
]
alias: coop = [ mode  1; map $arg1 ]
alias: corners = [ selectcorners 1; dragging 1; onrelease [ selectcorners 0; dragging 0 ] ]
alias: curmap = [rpg]
alias: defaultmodifier = [0]
alias: delta_edit_0 = [ editfacewentpush $arg1 1 ]
alias: delta_edit_10 = [ entautoview $arg1 ]
alias: delta_edit_1 = [ gridpower (+ $arg1 $gridpower) ]
alias: delta_edit_2 = [ editfacewentpush $arg1 0 ]
alias: delta_edit_3 = [ editfacewentpush $arg1 2 ]
alias: delta_edit_4 = [ editrotate $arg1 ]
alias: delta_edit_5 = [ entproperty 0 $arg1 ]
alias: delta_edit_6 = [ edittex $arg1 ]
alias: delta_edit_9 = [ selectbrush $arg1 ]
alias: delta_game_0 = [ if (= $arg1 1) [ weapon 2 3 5 ] [ weapon 4 1 5 ] ]
alias: delta_game_1 = [
  zfov = (+ $zfov (* $arg1 (div $zfov -5)))
  if (< $zfov 10)  [ zfov = 10 ]
  if (> $zfov 120) [ zfov = 120 ]
  fov $zfov
]
alias: demo = [ stopdemo; mode -3; map $arg1 ]
alias: distort = [
    TEMP reflect, refract, fade;
    
    MAD temp, dudv, 0.4, projtc;
    TXP reflect, temp, texture[0], 2D;
    TXP refract, temp, texture[3], 2D;
    TXP fade.a, projtc, texture[3], 2D;
    MAD result.color.a, fade, 4, projtc.z;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
]
alias: dmsp = [ mode -1; map $arg1 ]
alias: do = [ arg1 ]
alias: domodifier = [ modifier = $arg1; onrelease [ modifier = $defaultmodifier ] ]
alias: drag = [ dragging 1; onrelease [ dragging 0 ] ]
alias: ea = [ at (entget) (+ $arg1 1) ]
alias: editbindmod = [
  editbind $arg1 [@arg2 1; onrelease [@@arg2 0]]
]
alias: editbindvar = [
  editbind $arg1 [@arg2 (= $@arg2 0); if (= $@arg2 0) [echo @@arg2 OFF] [ echo @@arg2 ON]]
]
alias: editcopy = [
  if (|| havesel [! (enthavesel)]) [
    entcopybuf = ""
    entcopy
    copy
  ] [
    entcopybuf = (entget)
  ]
]
alias: editcut = [  
  hadselection = (havesel)
  moving 1
  if ($moving) [
    copy;     entcopy
    delcube;  delent
    onrelease [ 
      moving 0
      paste
      entpaste
      if ( ! $hadselection ) [ cancelsel ]
    ]
  ]
]
alias: editdel = [ delcube; delent ]
alias: editdrag = [ cancelsel; || (entdrag) [ drag ] ]
alias: editextend = [ || entdrag [ selextend; reorient; editmove ] ]
alias: editfacewentpush = [ 
  
  if (|| [havesel] [! (enthavesel)] ) [
    if ($moving) [ 
      pushsel $arg1 
    ] [ 
      entcancel
      editface $arg1 $arg2
    ] 
  ] [
      if ($entmoving) [ entpush $arg1 ] [ ent_action_@(et) ]
  ]
]
alias: editflip = [ flip; entflip ]
alias: edithud = [
    if (enthavesel) [concatword (entget) " : " (enthavesel) " selected"]
]
alias: editmovecorner = [ editmovewith selcorners ]
alias: editmovedrag = [ editmovewith editdrag ]
alias: editmove = [ moving 1; onrelease [ moving 0 ]; result $moving ]
alias: editmovewith = [
  if (havesel) [
    || (editmove) [ @arg1 ]
    onrelease [ moving 0; dragging 0 ]
  ] [
    @arg1
  ]
]
alias: editpaste = [ 
  cancelpaste = (! (|| enthavesel havesel));
  if (strcmp "" $entcopybuf) [
    pastehilite
    reorient 
    onrelease [ 
      if (opaquepaste) delcube 
      paste
      entpaste
      if ($cancelpaste) [ cancelsel ] 
    ] 
  ] [
    entreplace
    if ($cancelpaste) [ cancelsel ] 
  ] 
]
alias: editrotate = [ 
  || [ entdirection $arg1 15 ] [ 
      rotate $arg1
      entrotate $arg1 
    ] 
]
alias: efficiency = [ mode 6; map $arg1 ]
alias: ent_action_barrel = [ entproperty 1 ( * $arg1 1 ) ]
alias: ent_action_base = [ entproperty 0 ( * $arg1 1 ) ]
alias: ent_action_box = [ entproperty 1 ( * $arg1 1 ) ]
alias: ent_action_bullets = [ ent_action_cycle $arg1 rockets shells ]
alias: ent_action_carrot = [ entproperty 0 ( * $arg1 1 ) ]
alias: ent_action_cartridges = [ ent_action_cycle $arg1 quaddamage grenades ]
alias: ent_action_cycle = [ entset ( if ( > $arg1 -1 ) [ result $arg2 ] [ result $arg3 ] ) ]
alias: ent_action_elevator = [ entproperty 1 ( * $arg1 1 ) ]
alias: ent_action_envmap = [ entproperty 0 ( * $arg1 5 ) ]
alias: ent_action_greenarmour = [ ent_action_cycle $arg1 yellowarmour healthboost ]
alias: ent_action_grenades = [ ent_action_cycle $arg1 cartridges riflerounds ]
alias: ent_action_healthboost = [ ent_action_cycle $arg1 greenarmour health ]
alias: ent_action_health = [ ent_action_cycle $arg1 healthboost yellowarmour ]
alias: ent_action_jumppad = [ entproperty 0 ( * $arg1 5 ) ]
alias: ent_action_light = [ entproperty 0 ( * $arg1 5 ) ]
alias: ent_action_mapmodel = [ entproperty 1 ( * $arg1 1 ) ]
alias: ent_action_monster = [ entproperty 1 ( * $arg1 1 ) ]
alias: ent_action_particles = [ entproperty 0 ( * $arg1 1 ) ]
alias: ent_action_platform = [ entproperty 1 ( * $arg1 1 ) ]
alias: ent_action_playerstart = [ entproperty 0 ( * $arg1 15 ) ]
alias: ent_action_quaddamage = [ ent_action_cycle $arg1 shells cartridges ]
alias: ent_action_respawnpoint = [ entproperty 0 ( * $arg1 15 ) ]
alias: ent_action_riflerounds = [ ent_action_cycle $arg1 grenades rockets ]
alias: ent_action_rockets = [ ent_action_cycle $arg1 riflerounds bullets ]
alias: ent_action_shells = [ ent_action_cycle $arg1 bullets quaddamage ]
alias: ent_action_sound = [ entproperty 0 ( * $arg1 1 ) ]
alias: ent_action_spotlight = [ entproperty 0 ( * $arg1 5 ) ]
alias: ent_action_teledest = [ entproperty 1 ( * $arg1 1 ) ]
alias: ent_action_teleport = [ entproperty 0 ( * $arg1 1 ) ]
alias: ent_action_yellowarmour = [ ent_action_cycle $arg1 health greenarmour ]
alias: entadd = [ entaddmove; entmoving 0; ]
alias: entaddmove = [ entmoving 2 ]
alias: entattributes = [   guitext type ;  guislider tmp0 0 3 entupdate ; ]
alias: entcomplete = [ listcomplete $arg1 "light mapmodel playerstart envmap particles sound spotlight shells bullets rockets riflerounds grenades cartridges health healthboost greenarmour yellowarmour quaddamage teleport teledest monster carrot jumppad base respawnpoint box barrel platform elevator" ]
alias: entcopybuf = [mapmodel 266 74 0 0]
alias: entdirection = [
  if ( && (enthavesel) [ = (havesel) 0 ] ) [
    if (inlist (et) $entswithdirection) [
      if (> $arg1 0) [
        entproperty 0 @@arg2
        if (> (ea 0) 360) [ entproperty 0 -360 ]          
      ] [
        entproperty 0 -@@arg2
        if (< (ea 0) 0) [ entproperty 0 360 ]
      ]
    ]
    result 1
  ] [
    result 0
  ]
]
alias: entdrag = [ entaddmove; onrelease [entmoving 0]; result $entmoving ]
alias: entfind = [ 
  if (= ($numargs) 1) [
    entselect     [ equaltype @@arg1 ]     
  ] [ if (= ($numargs) 2) [
    entselect [ && (equaltype @@arg1)         [equalattr 0 @@arg2] ]
  ] [ if (= ($numargs) 3) [
    entselect [ && (equaltype @@arg1) (&&     [equalattr 0 @@arg2] [equalattr 1 @@arg3]) ]
  ] [ if (= ($numargs) 4) [
    entselect [ && (equaltype @@arg1) (&& (&& [equalattr 0 @@arg2] [equalattr 1 @@arg3])     [equalattr 2 @@arg4]) ]
  ] [
    entselect [ && (equaltype @@arg1) (&& (&& [equalattr 0 @@arg2] [equalattr 1 @@arg3]) (&& [equalattr 2 @@arg4] [equalattr 3 @@arg5])) ]
  ]]]]
]
alias: entproperty = [
  entloop [
    a0 = (ea 0)
    a1 = (ea 1)
    a2 = (ea 2)
    a3 = (ea 3)
    do [a@arg1 = (+ (ea @arg1) @arg2)]
    entset (et) $a0 $a1 $a2 $a3
  ]
]
alias: entreplace = [ 
  do [
    if (enthavesel) [] [ newent @entcopybuf ]
    entset @entcopybuf 
  ]
]
alias: entswithdirection = [playerstart teledest mapmodel monster box barrel platform elevator]
alias: enttoggle = [ entmoving 1; entmoving 0; ]
alias: enttypelength = [30]
alias: enttypelist = [ 
  light mapmodel playerstart envmap particles sound
  shells bullets rockets riflerounds grenades cartridges
  health healthboost greenarmour yellowarmour quaddamage
  teleport teledest
  monster carrot jumppad
  base respawnpoint
  spotlight 
  box barrel platform elevator
  ""
]
alias: enttypeselect = [     
  n = $enttypelength
  next = (+ (listindex $enttypelist (et)) $arg1)
  if (< $next 0)  [ next = (- $n 1) ]
  if (= $next $n) [ next = 0 ]
  next = (at $enttypelist $next)
  entset $next (ea 0) (ea 1) (ea 2) (ea 3) 
]
alias: entupdate = [ entset $tmpt $tmp0 $tmp1 $tmp2 $tmp3 ]
alias: equalattr = [
  if (strcmp * $arg2) [ result 1 ] [
    result (= (ea $arg1) $arg2)
  ]
]
alias: equaltype = [
  if (strcmp * $arg1) [ result 1 ] [
    result (strcmp (et) $arg1)
  ]
]
alias: et = [ at (entget) 0 ]
alias: explosionshader = [
    shader 0 $arg1 [
        !!ARBvp1.0
        ATTRIB opos = vertex.position; 
        OUTPUT spos = result.position;
        
        TEMP wobble; 
        DP3 wobble, opos, program.env[0]; 
        MAD wobble, program.env[1].w, 0.002, wobble; 
        FRC wobble, wobble; 
        SUB wobble, wobble, 0.5; 
        ABS wobble, wobble; 
        MUL wobble, wobble, 0.5; 
        
        MAD wobble.xyz, wobble, opos, opos;
        MOV wobble.w, opos.w;
        
        DP4 spos.x, state.matrix.mvp.row[0], wobble; 
        DP4 spos.y, state.matrix.mvp.row[1], wobble; 
        DP4 spos.z, state.matrix.mvp.row[2], wobble; 
        DP4 spos.w, state.matrix.mvp.row[3], wobble;
       
        MOV result.color, vertex.color;

        @arg2 
        
        @fogcoord
        END
    ] [ 
        @fpstart
        OPTION ARB_fog_linear;
        TEMP dtc, diffuse, blend, tint;
        
        TEX dtc, @arg3, texture[0], 2D;
        MAD dtc, dtc, 0.1, fragment.texcoord[0]; 
        TEX diffuse, dtc, texture[0], 2D;
        
        TEX blend, fragment.texcoord[1], texture[1], 2D; 
        MAD tint, blend.a, { 0, 0, -0.5, 0 }, { 0, 0, 0.5, 0 }; 
        MUL blend, blend.a, 4; 

        MAD diffuse, diffuse, blend, tint;
        MUL result.color, diffuse, fragment.color;

        END
    ]
]
alias: ffa = [ mode  0; map $arg1 ]
alias: fogcoord = [
    TEMP fogplane;
    MAD fogplane, state.matrix.modelview.row[2], program.env[8], program.env[9];
    DP4 result.fogcoord, -opos, fogplane;
]
alias: fpopts = [
    OPTION ARB_precision_hint_fastest;
    
]
alias: fpstart = [
    !!ARBfp1.0
    
    OPTION ARB_precision_hint_fastest;
    

]
alias: fsps = [
    
    !!ARBfp1.0
    
    OPTION ARB_precision_hint_fastest;
    


    TEMP sample;
    TEX sample, fragment.texcoord[0], texture[0], RECT;
]
alias: fsvs = [
    !!ARBvp1.0
    MOV result.position, vertex.position;   
    MOV result.texcoord[0], vertex.texcoord[0];
]
alias: genentattributes = [
    entattributes = ""
    n = ( listlen $arg2 )
    loop i $n [       
        do [
          t@i = [ guitext @(at $arg2 $i) ]
          a@i = [ guislider tmp@i @(at $arg3 (* 2 $i)) @(at $arg3 (+ 1 (* 2 $i))) entupdate ]
          entattributes = [ @@entattributes @t@@i; @a@@i; ]
        ]
    ]
]
alias: genmapitems = [
    n = (listlen $arg1)
    loop i $n [
        curmap = (at $arg1 $i)
        aliasname = (concatword bestscore_ $curmap)
        title = (if (= (getalias $aliasname) 0) [ result $curmap ] [ concatword $curmap " (best score: " (getalias $aliasname) ")" ])
        guibutton $title (concat map $curmap) "sauer"
    ]
]
alias: glass = [ editmat glass ]
alias: glowtex = [texture[5]]
alias: grabbing = [0]
alias: guilistsplit = [
  guilist [
    i = 0
    z = ( div ( listlen $arg2 ) $arg1 )
    loop a $arg1 [
      guilist [
        t = ( + $i $z )
        while [ < $i $t ] [
          n = (at $arg2 $i)
          @@arg3
          i = (+ $i 1)
        ]
      ]
    ]
  ]
]
alias: guirolloveraction = [quit]
alias: guirolloverimgaction = [map village]
alias: guirolloverimgpath = [packages/base/village.jpg]
alias: guirollovername = [quit]
alias: hadselection = [0]
alias: hmapctrl = [ hmapedit $arg1; passthrough $arg1]
alias: i = [4]
alias: initentgui = [
  tmpt = ( et )
  tmp0 = ( ea 0 )
  tmp1 = ( ea 1 )
  tmp2 = ( ea 2 )
  tmp3 = ( ea 3 )
]
alias: inlist = [
  r = 0
  n = ( listlen $arg2 )
  loop i $n [
    if (strcmp $arg1 (at $arg2 $i)) [
      r = 1 
    ]
  ]
  result $r
]
alias: instaasn = [ mode 16; map $arg1 ]
alias: instacapture = [ mode 13; map $arg1 ]
alias: insta = [ mode  4; map $arg1 ]
alias: instateam = [ mode 5; map $arg1 ]
alias: keys = [MOUSE1 MOUSE2 MOUSE3 MOUSE4 MOUSE5 SPACE LCTRL RCTRL ALT TAB ESCAPE BACKQUOTE SHIFT BACKSPACE ENTER INSERT DELETE HOME END PAGEUP PAGEDOWN A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12]
alias: lava = [ editmat lava ]
alias: level_trigger_1 = [ 
    if (= $triggerstate -1) [echo "This door is opened elsewhere."]
]
alias: lightb = [192]
alias: lightbright = [0]
alias: lightcmd = [
    lightr = (at $lightrgb 0)
    lightg = (at $lightrgb 1)
    lightb = (at $lightrgb 2)
    if (= $lightbright 0) [
        if (strcmp $lightrgb "255 255 255") [
            lightr = 192; lightg = 192; lightb = 192
        ] [
            lightr = (div $lightr 2); lightg = (div $lightg 2); lightb = (div $lightb 2)
         ]
    ]
    result (concat newent light $lightradius $lightr $lightg $lightb)
]
alias: lightcolour = [0]
alias: lightg = [192]
alias: lightr = [192]
alias: lightradius = [128]
alias: lightrgb = [255 255 255]
alias: listindex = [
  s = 0
  n = (listlen $arg1)
  loop i $n [
    if (strcmp $arg2 (at $arg1 $i)) [
      s = $i
    ]
  ]
  result $s
]
alias: loopconcat = [
    sum = "";
    loop $arg1 $arg2 [sum = (concat $sum (arg3))]
    result $sum;
]
alias: lse = [
  line = ""
  count = 0
  entloop [
    line  = ( concatword $line (entget) "		" )
    count = ( + $count 1 )
    if (> $count 4) [
      echo $line
      line = ""
      count = 0
    ]
  ]
  if (> $count 0 ) [ echo $line ]
  echo (enthavesel) entities selected
]
alias: macro = [
    $arg1 = (concat [format [@@arg2]] (loopconcat i $numargs [concatword " $arg" (+ $i 1)]))
]
alias: mainmaps = [metl4 deathtek fanatic_quake aard3c metl2 ruby curvedm metl3 nmp8_d complex douze killfactory lostinspace oasis aqueducts corruption thor]
alias: mapcomplete = [ complete $arg1 packages/base ogz ]
alias: mapmodellist = [
"tree1"
"dcp/tree2"
"dcp/tree3"
"dcp/palmtree"
"dcp/thorns"
"dcp/plant1"
"dcp/grass"
"dcp/ivy"
"dcp/barrel"
"dcp/streetlamp"
"dcp/bench"
"dcp/pillar"
"dcp/waterbowl"
"dcp/jumppad2"
"dcp/leafs"
"dcp/valve"
"dcp/palette"
"dcp/vent"
"dcp/mushroom"
"dcp/biotank"
"dcp/groundlamp"
"dcp/console"
"dcp/turret"
"carrot"
"switch1"
"switch2"
"doors/door_01"
"doors/door_02"
"doors/door_03"
"dcp/cask"
"dcp/cart"
"dcp/candle"
"dcp/vase"
"dcp/sack"
"dcp/chandelier"
"dcp/chest"
"dcp/firebowl"
"dcp/smplant"
"dcp/insect"
"dcp/reed"
"makke/nocamp"
"makke/strahler"
"tentus/food-drink/goblet"
"tentus/food-drink/apple"
"tentus/food-drink/pear"
"tentus/food-drink/appleslice"
"tentus/food-drink/meat"
"tentus/food-drink/bowl"
"tentus/food-drink/pieslice"
"tentus/food-drink/mug"
"tentus/food-drink/winebottle"
"tentus/food-drink/pie"
"tentus/books/flat"
"tentus/books/multi"
"tentus/chains/chain"
"tentus/chains/curvechain"
"tentus/barrel"
"tentus/sidebarrel"
"tentus/pot1"
"tentus/rope"
"tentus/ropelamp"
"tentus/ladder"
"tentus/fattree"
"tentus/moneybag"
"tentus/woodbench"
"tentus/hammer"
"tentus/anvil"
"tentus/spear"
"tentus/key"
"tentus/redshield"
"tentus/greenshield"
"tentus/bombs"
"objects/window01"
"objects/sign01"
"objects/lamp01"
"objects/chair01"
"objects/bed01"
"vegetation/tree00"
"vegetation/tree01"
"vegetation/bush01"
"vegetation/tree02"
"vegetation/tree04"
"vegetation/tree05"
"vegetation/tree06"
"vegetation/tree07"
"vegetation/tree03"
"objects/window02/window02_1"
"objects/window02/window02_2"
"objects/bench01"
"objects/lantern01"
"objects/lantern02"
"objects/woodchop"
"objects/table01"
"objects/torch"
"objects/torch_cold"
"objects/fire"
"objects/sail01"
"objects/well_base"
"objects/well_roof"
"objects/lamp02"
"objects/med_chand"]
alias: maprotation = [
    n = (listlen $arg1)
    loop i $n [
        curmap = (at $arg1 $i)
        next = (mod (+ $i 1) $n)
        nextmap = (at $arg1 $next)
        (if (= $numargs 2) [concatword nextmap_ $arg2 $curmap] [concatword nextmap_ $curmap]) = $nextmap
    ]
]
alias: mdlopt = [ >= (strstr $modeltype $arg1) 0 ]
alias: menubind = [ tobind = $arg1; showgui binditto ]
alias: modelshader = [
    modeltype = $arg2
    shader 0 $arg1 [
        @vpstart
        ATTRIB onormal = vertex.normal; 
        @(if (mdlopt "n") [result "ATTRIB otangent = vertex.texcoord[1];"])
        PARAM ocampos = program.env[1];
        PARAM lightdir = program.env[0];
        PARAM ambient = program.env[3];

        MOV result.color, vertex.color;
        MOV result.texcoord[0], vertex.texcoord[0];
       
        @(if (|| (mdlopt "e") (mdlopt "s")) [result [
            TEMP camvec;
            SUB camvec, ocampos, opos;
            @(normalize camvec camvec)
        ]])

        @(if (mdlopt "n") [result [
            TEMP obitangent;
            XPD obitangent, onormal, otangent;
            @(normalize obitangent obitangent)
            MUL obitangent, obitangent, otangent.w;

            DP3 result.texcoord[1].x, lightdir, otangent;
            DP3 result.texcoord[1].y, lightdir, obitangent;
            DP3 result.texcoord[1].z, lightdir, onormal;

            @(if (|| (mdlopt "s") (mdlopt "e")) [result [
                DP3 result.texcoord[2].x, camvec, otangent;
                DP3 result.texcoord[2].y, camvec, obitangent;
                DP3 result.texcoord[2].z, camvec, onormal;
            ]])
            
            @(if (mdlopt "e") [result [
                
                
                DP3 result.texcoord[3].x, -state.matrix.texture.row[1], otangent;
                DP3 result.texcoord[3].y, -state.matrix.texture.row[1], obitangent;
                DP3 result.texcoord[3].z, -state.matrix.texture.row[1], onormal;

                DP3 result.texcoord[4].x, state.matrix.texture.row[2], otangent;
                DP3 result.texcoord[4].y, state.matrix.texture.row[2], obitangent;
                DP3 result.texcoord[4].z, state.matrix.texture.row[2], onormal;

                DP3 result.texcoord[5].x, state.matrix.texture.row[0], otangent;
                DP3 result.texcoord[5].y, state.matrix.texture.row[0], obitangent;
                DP3 result.texcoord[5].z, state.matrix.texture.row[0], onormal;
            ]])
        ]] [result [
            @(if (mdlopt "s") [result [
                MOV result.texcoord[1], onormal;
                MOV result.texcoord[2], lightdir; 
                ADD result.texcoord[3], lightdir, camvec;
            ]] [result [
                TEMP light;
                DP3 light, onormal, lightdir;
                MUL light, light, 1.5;
                MAX light, light, ambient;
                MUL result.texcoord[1], light, vertex.color;
            ]])
            @(if (mdlopt "e") [result [
                TEMP rvec, invfresnel;
                DP3 invfresnel, camvec, onormal;
                MUL rvec, invfresnel, onormal; 
                MAD rvec, rvec, 2, -camvec;
                DP3 result.texcoord[4].x, -state.matrix.texture.row[1], rvec;
                DP3 result.texcoord[4].y, state.matrix.texture.row[2], rvec;
                DP3 result.texcoord[4].z, state.matrix.texture.row[0], rvec;
                MAX invfresnel, invfresnel, 0;
                MAD result.texcoord[4].w, program.env[6].x, invfresnel, program.env[6].y;
            ]])
        ]])

        @fogcoord
        END
    ] [
        @fpstart
        OPTION ARB_fog_linear;
        ATTRIB dtc = fragment.texcoord[0];
        @(if (mdlopt "n") [result "ATTRIB lightdir = fragment.texcoord[1];"])
        @(if (! (|| (mdlopt "n") (mdlopt "s"))) [result "ATTRIB color = fragment.texcoord[1];"])
        @(if (mdlopt "s") [result [
            @(if (! (mdlopt "n")) [result [
                ATTRIB lightdir = fragment.texcoord[2];
            ]])
            PARAM specfactor = 128;
            PARAM specintensity = program.env[2];
        ]])
        PARAM ambient = program.env[3];
        PARAM glowscale = program.env[4];
        TEMP diffuse, light;

        TEX diffuse, dtc, texture[0], 2D;

        @(if (mdlopt "n") [result [
            TEMP normal;
            TEX normal, dtc, texture[3], 2D;
            MAD normal, normal, 2, -1;

            @(if (|| (mdlopt "e") (mdlopt "s")) [result [
                TEMP camvec;
                @(normalize camvec fragment.texcoord[2])
            ]])
        ]])

        @(if (mdlopt "s") [result [
            TEMP spec, halfangle;
            @(if (mdlopt "n") [result [
                ADD halfangle, lightdir, camvec;
                @(normalize halfangle halfangle)
            ]] [result [
                TEMP normal;
                @(normalize halfangle fragment.texcoord[3])
                @(normalize normal fragment.texcoord[1])
            ]])
            DP3_SAT spec, halfangle, normal;
            POW spec, spec.x, specfactor.x;
            MUL spec, spec, specintensity;
        ]])

        @(if (|| (mdlopt "n") (mdlopt "s")) [result [
            DP3_SAT light, normal, lightdir;
            MUL light.rgb, light, 1.5;
            MAX light, light, ambient;
        ]])

        @(if (mdlopt "m") [result [
            TEMP masks;
            TEX masks, dtc, texture[1], 2D;
                
            @(if (mdlopt "s") [result "MUL spec, spec, masks.r;"])   
        ]])
        
        @(if (mdlopt "s") [result [
            MAD light, light, diffuse, spec;
            MUL @(if (|| (mdlopt "m") (mdlopt "e")) [result "light"] [result "result.color"]), light, fragment.color; 
        ]] [if (mdlopt "n") [result [
            MUL light, light, diffuse;
            MUL @(if (|| (mdlopt "m") (mdlopt "e")) [result "light"] [result "result.color"]), light, fragment.color;
        ]] [result [
            MUL @(if (|| (mdlopt "m") (mdlopt "e")) [result "light"] [result "result.color"]), color, diffuse;
        ]]])

        @(if (mdlopt "m") [result [
            TEMP glow;
            MUL glow, diffuse, glowscale;

            @(if (mdlopt "e") [result [
                LRP light, masks.g, glow, light;

                TEMP reflect;
                @(if (mdlopt "n") [result [
                    TEMP invfresnel, rvects, rvec;
                    DP3 invfresnel, camvec, normal;
                    MUL rvects, invfresnel, normal; 
                    MAD rvects, rvects, 2, -camvec; 

                    DP3 rvec.x, rvects, fragment.texcoord[3];
                    DP3 rvec.y, rvects, fragment.texcoord[4];
                    DP3 rvec.z, rvects, fragment.texcoord[5];

                    MAX invfresnel, invfresnel, 0;
                    MAD invfresnel, program.env[6].x, invfresnel, program.env[6].y;

                    TEX reflect, rvec, texture[2], CUBE;
                    MUL masks.b, masks.b, invfresnel; 
                ]] [result [
                    TEX reflect, fragment.texcoord[4], texture[2], CUBE;
                    MUL masks.b, masks.b, fragment.texcoord[4].w; 
                ]])
                LRP result.color, masks.b, reflect, light;
            ]] [result [
                LRP result.color, masks.g, glow, light;
            ]])   

            MUL result.color.a, diffuse.a, fragment.color.a;
        ]])

        END
    ]
]
alias: modeltype = [nme]
alias: modifier = [0]
alias: moremaps1 = [academy tartech orbe hades paradigm wake5 island roughinery shadowed DM_BS1 shindou stemple moonlite darkdeath thetowers kmap5 ot]
alias: moremaps2 = [ogrosupply fragplaza frostbyte fanatic_castle_trap nmp10 neonpanic orion katrez_d serpentine aard3b ksauer1 fanatic_complexities q1dm4 phosgene pgdm oddworld fanatic_caves]
alias: n = [5]
alias: newbrush = [
  brushmax = (+ $brushmax 1)
  do [ 
    brush_@brushmax = [
      brushname = [@@@arg1]
      clearbrush
      @@(if (> $numargs 1) [result [brushhandle @arg2 @arg3; brushverts [@@arg4]]])
    ]
  ]
]
alias: newentgui = [
  do [
    genentattributes $arg1 $arg2 $arg3
    newgui @arg1 [
      @quickcommands
      guitab type 
      guilistsplit 2 $enttypelist [
          guibutton $n [ entset @n ]       
      ]  
      guitab attr
      guitext $tmpt
      guitext ""
      @entattributes
    ]
  ]
]
alias: newmapsize = [10]
alias: newname = [unnamed]
alias: next = [0]
alias: nextmap_aard3b = [ksauer1]
alias: nextmap_aard3 = [boo2]
alias: nextmap_aard3c = [metl2]
alias: nextmap_academy = [tartech]
alias: nextmap_aqueducts = [corruption]
alias: nextmap_battleofthenile = [mechanic]
alias: nextmap_boo2 = [id]
alias: nextmap_box_demo = [platform_demo]
alias: nextmap_capture_asteroids = [venice]
alias: nextmap_capture_corruption = [hades]
alias: nextmap_capture_c_valley = [nmp4]
alias: nextmap_capture_face-capture = [nmp9]
alias: nextmap_capture_fb_capture = [urban_c]
alias: nextmap_capture_fc3 = [ph-capture]
alias: nextmap_capture_frostbyte = [ogrosupply]
alias: nextmap_capture_hades = [asteroids]
alias: nextmap_capture_lostinspace = [face-capture]
alias: nextmap_capture_monastery = [corruption]
alias: nextmap_capture_nevil_c = [lostinspace]
alias: nextmap_capture_nmp4 = [nmp8_c]
alias: nextmap_capture_nmp8_c = [fc3]
alias: nextmap_capture_nmp9 = [c_valley]
alias: nextmap_capture_ogrosupply = [river_c]
alias: nextmap_capture_paradigm = [fb_capture]
alias: nextmap_capture_ph-capture = [monastery]
alias: nextmap_capture_relic = [frostbyte]
alias: nextmap_capture_river_c = [paradigm]
alias: nextmap_capture_serenity = [nevil_c]
alias: nextmap_capture_urban_c = [serenity]
alias: nextmap_capture_venice = [relic]
alias: nextmap_chronos = [chthon]
alias: nextmap_chthon = [wdcd]
alias: nextmap_complex = [douze]
alias: nextmap_corruption = [thor]
alias: nextmap_darkdeath = [thetowers]
alias: nextmap_deathtek = [fanatic_quake]
alias: nextmap_demomap = [rpg_01]
alias: nextmap_DM_BS1 = [shindou]
alias: nextmap_door_demo = [box_demo]
alias: nextmap_douze = [killfactory]
alias: nextmap_drianmp4 = [aard3]
alias: nextmap_fanatic_castle_trap = [nmp10]
alias: nextmap_fanatic_caves = [metl4]
alias: nextmap_fanatic_complexities = [q1dm4]
alias: nextmap_fanatic_quake = [aard3c]
alias: nextmap_firstevermap = [battleofthenile]
alias: nextmap_fragplaza = [frostbyte]
alias: nextmap_frostbyte = [fanatic_castle_trap]
alias: nextmap_frozenbase = [orgosville]
alias: nextmap_hades = [paradigm]
alias: nextmap_id = [nmp7]
alias: nextmap_island = [roughinery]
alias: nextmap_katrez_d = [serpentine]
alias: nextmap_killfactory = [lostinspace]
alias: nextmap_kmap5 = [ot]
alias: nextmap_k_rpg1 = [demomap]
alias: nextmap_ksauer1 = [fanatic_complexities]
alias: nextmap_ladder = [spiralz]
alias: nextmap = [level9]
alias: nextmap_level9 = [vr]
alias: nextmap_lostinspace = [oasis]
alias: nextmap_mechanic = [chronos]
alias: nextmap_metl2 = [ruby]
alias: nextmap_metl3 = [nmp8_d]
alias: nextmap_metl4 = [deathtek]
alias: nextmap_moonlite = [darkdeath]
alias: nextmap_neon = [drianmp4]
alias: nextmap_neonpanic = [orion]
alias: nextmap_nmp10 = [neonpanic]
alias: nextmap_nmp7 = [vootdm1]
alias: nextmap_nmp8_d = [complex]
alias: nextmap_nod = [ogromines]
alias: nextmap_n_sp1 = [n_sp2]
alias: nextmap_n_sp2 = [door_demo]
alias: nextmap_oasis = [aqueducts]
alias: nextmap_oddworld = [fanatic_caves]
alias: nextmap_ogromines = [skycastle]
alias: nextmap_ogrosupply = [fragplaza]
alias: nextmap_ogrowaystation = [frozenbase]
alias: nextmap_orbe = [hades]
alias: nextmap_orgosville = [theancientstone]
alias: nextmap_orion = [katrez_d]
alias: nextmap_ot = [ogrosupply]
alias: nextmap_paradigm = [wake5]
alias: nextmap_pgdm = [oddworld]
alias: nextmap_phosgene = [pgdm]
alias: nextmap_platform_demo = [level9]
alias: nextmap_q1dm4 = [phosgene]
alias: nextmap_roughinery = [shadowed]
alias: nextmap_rpg_01 = [village]
alias: nextmap_rpg = [k_rpg1]
alias: nextmap_ruby = [curvedm]
alias: nextmap_secondevermap = [firstevermap]
alias: nextmap_serpentine = [aard3b]
alias: nextmap_shadowed = [DM_BS1]
alias: nextmap_shindou = [stemple]
alias: nextmap_skycastle = [ladder]
alias: nextmap_sp2 = [stsp1]
alias: nextmap_sp3 = [sp2]
alias: nextmap_space = [nod]
alias: nextmap_spiralz = [secondevermap]
alias: nextmap_stemple = [moonlite]
alias: nextmap_stsp1 = [n_sp1]
alias: nextmap_tartech = [orbe]
alias: nextmap_theancientstone = [sp3]
alias: nextmap_thetowers = [kmap5]
alias: nextmap_thor = [academy]
alias: nextmap_village = [rpg]
alias: nextmap_vootdm1 = [vootdm2]
alias: nextmap_vootdm2 = [vootdm3]
alias: nextmap_vootdm3 = [space]
alias: nextmap_vr = [ogrowaystation]
alias: nextmap_wake5 = [island]
alias: nextmap_wdcd = [yesterday]
alias: nextmap_yesterday = [neon]
alias: noclip = [ editmat noclip ]
alias: normalize = [format [
    DP3 %1.w, %2, %2;
    RSQ %1.w, %1.w;
    MUL %1.xyz, %1.w, %2;
]   $arg1  $arg2]
alias: normtex = [texture[4]]
alias: oldmaps1 = [battleofthenile mechanic chronos chthon wdcd yesterday neon drianmp4 aard3 boo2 id nmp7 vootdm1 vootdm2 vootdm3 space nod]
alias: oldmaps2 = [ogromines skycastle ladder spiralz secondevermap firstevermap]
alias: opaquepaste = [1]
alias: passthroughcube_bak = [1]
alias: passthrough = [ 
  passthroughsel $arg1; 
  if ($arg1) [
    passthroughcube_bak = $passthroughcube
    passthroughcube 1
  ] [
    passthroughcube $passthroughcube_bak
  ]
  entcancel 
  if ( setting_entediting ) [ entediting ( ! $arg1 ) ]
  
]
alias: pixelparam0 = [program.env[16]]
alias: pixelparam1 = [program.env[17]]
alias: pixelparam2 = [program.env[18]]
alias: pixelparam3 = [program.env[19]]
alias: pixelparam4 = [program.env[20]]
alias: pixelparam5 = [program.env[21]]
alias: pixelparam6 = [program.env[22]]
alias: pixelparam7 = [program.env[23]]
alias: playasong = [ music (concatword "fanatic/" (+ 1 (rnd 31)) ".ogg") playasong ]
alias: quickcommands = [
  guitext "Quick Commands:"
  guitext ""
  guibutton "savemap      (F5)" "savemap"
  guibutton quicklight          "calclight -1"
  guibutton "optimize map"      "remip"
  guibutton "new entity"        "newent shells"
  guitext ""
  guibutton newmap
  guitext ""
  guibutton help "showgui editing"
]
alias: quine = [ echo (format "quine = [%1]" $quine) ]
alias: r = [1]
alias: reflectivity = [MAD invfresnel, invfresnel, 0.5, 0.5;]
alias: regencapture = [ mode 14; map $arg1 ]
alias: replaceents = [
  if $editing [
    entfind @(entget)
    entset @arg1 @arg2 @arg3 @arg4 @arg5
    echo Replaced (enthavesel) entities  
  ]
]
alias: resetlight = [
    lightcolour = 0
    lightrgb = "255 255 255"
    lightbright = 1
    lightradius = 128
]
alias: rgbafog = [format [
    TEMP fog;
    SUB fog, state.fog.params.z, fragment.fogcoord.x;
    MUL_SAT fog, fog, state.fog.params.w;
    LRP result.color, fog, %1, %2;
]   $arg1  $arg2]
alias: rgbfog = [1]
alias: rpgmaps = [k_rpg1 demomap rpg_01 village rpg]
alias: sample4corners = [
    TEMP s00, s02, s20, s22;
    TEX s00, fragment.texcoord[1], texture[0], RECT;
    TEX s02, fragment.texcoord[2], texture[0], RECT;
    TEX s20, fragment.texcoord[3], texture[0], RECT;
    TEX s22, fragment.texcoord[4], texture[0], RECT;
]
alias: savemap_name = [valhalla]
alias: selcorners = [ if ($hmapedit) [ hmapselect ] [ cancelsel; || (entdrag) [ corners ] ] ]
alias: selectbrush = [
  brushindex = ( + $brushindex $arg1 )
  if (< $brushindex 0) [ brushindex = $brushmax ]
  if (> $brushindex $brushmax) [ brushindex = 0 ]
  do [brush_@brushindex]
  echo $brushname
]
alias: selentedit = [ "saycommand" ( concatword "/entset " (entget) ) ]
alias: selentfindall = [ do [ @( concatword "entfind " (entget) ) ] ]
alias: selreplaceents = [ "saycommand" ( concatword "/replaceents " (entget) ) ]
alias: setting_entediting = [1]
alias: setup4corners = [
    ADD result.texcoord[1], vertex.texcoord[0], { -1.5, -1.5, 0, 0 };        
    ADD result.texcoord[2], vertex.texcoord[0], {  1.5, -1.5, 0, 0 };        
    ADD result.texcoord[3], vertex.texcoord[0], { -1.5,  1.5, 0, 0 };        
    ADD result.texcoord[4], vertex.texcoord[0], {  1.5,  1.5, 0, 0 };        
]
alias: showentgui = [ 
  if (! (enthavesel)) [
    showgui quickedit
  ] [
    initentgui; 
    do [ showgui (et) ] 
  ]
]
alias: showmapshot = [ guibar; guiimage (concatword "packages/base/" (at $guirollovername 0) ".jpg") $guirolloveraction 4 1 "data/cube.png"]
alias: slowdmsp = [ mode -4; map $arg1 ]
alias: slowsp = [ mode -5; map $arg1 ]
alias: spec = [0]
alias: spmaps = [level9 vr ogrowaystation frozenbase orgosville theancientstone sp3 sp2 stsp1 n_sp1 n_sp2 door_demo box_demo platform_demo]
alias: sp = [ mode -2; map $arg1 ]
alias: sum = [ 
                TEX bloom, fragment.texcoord[1], texture[1], RECT;
                
             
                TEX scaled, fragment.texcoord[2], texture[2], RECT;
                
                    ADD bloom, bloom, scaled;
                
             
                TEX scaled, fragment.texcoord[3], texture[3], RECT;
                
                    ADD bloom, bloom, scaled;
                
             
                TEX scaled, fragment.texcoord[4], texture[4], RECT;
                
                    ADD bloom, bloom, scaled;
                
             
                TEX scaled, fragment.texcoord[5], texture[5], RECT;
                
                    ADD bloom, bloom, scaled;
                
             
                TEX scaled, fragment.texcoord[6], texture[6], RECT;
                
                    ADD bloom, bloom, scaled;
                
            ]
alias: t0 = [ guitext type ]
alias: t = [14]
alias: t1 = [ guitext radius ]
alias: t2 = [ guitext size ]
alias: t3 = [ guitext trigger ]
alias: title = [rpg]
alias: universaldelta = [
  do [delta_@(if $editing [ result edit ] [ result game ])_@modifier @arg1]
]
alias: vertexparam0 = [program.env[16]]
alias: vertexparam1 = [program.env[17]]
alias: vertexparam2 = [program.env[18]]
alias: vertexparam3 = [program.env[19]]
alias: vertexparam4 = [program.env[20]]
alias: vertexparam5 = [program.env[21]]
alias: vertexparam6 = [program.env[22]]
alias: vertexparam7 = [program.env[23]]
alias: vpstart = [
    !!ARBvp1.0
    
        OPTION ARB_position_invariant;
        ATTRIB opos = vertex.position; 
    
]
alias: water = [ editmat water ]
alias: watershader = [
    spec = $arg2
    rgbfog = $arg3
    distort = $arg4
    combine = $arg5
    shader 1 $arg1 [
        @vpstart
        TEMP tc;
        PARAM campos = program.env[0];
        PARAM seconds = program.env[1];
        @(if $spec [result "PARAM lightpos = program.env[2];"])

        DP4 result.texcoord[0].x, state.matrix.texture.row[0], opos;
        DP4 result.texcoord[0].y, state.matrix.texture.row[1], opos;
        SUB result.texcoord[0].z, opos.z, program.env[7]; 
        DP4 result.texcoord[0].w, state.matrix.texture.row[3], opos;
        MUL tc, vertex.texcoord[0], 0.1;
        MAD result.texcoord[1], seconds, 0.04, tc;
        MAD result.texcoord[2], seconds, -0.02, tc;
        SUB result.texcoord[3], campos, opos;
        @(if $spec [result "SUB result.texcoord[4], lightpos, opos;"])

        MOV result.color, vertex.color;

        @fogcoord

        END
    ] [
        @fpstart
        @(if $rgbfog [result "OPTION ARB_fog_linear;"])
        TEMP he, light, cam, bump, invfresnel, temp, dudv;

        ATTRIB projtc = fragment.texcoord[0];
        ATTRIB tc1 = fragment.texcoord[1];
        ATTRIB tc2 = fragment.texcoord[2];
        ATTRIB camts = fragment.texcoord[3];
        @(if $spec [result "ATTRIB lightts = fragment.texcoord[4];"])

        @(normalize cam camts)
        @(if $spec [result [
            @(normalize light lightts)
            ADD he, cam, light;
            @(normalize he he)
        ]])

        TEX dudv, tc1, texture[2], 2D;
        MAD dudv.xy, dudv, 2, -1;

        @distort

        @(if $spec [result [
            PARAM specfactor = 96;

            DP3_SAT he, he, bump;
            POW he, he.x, specfactor.w;
    
            MUL light, program.env[4], light.w;
            RCP_SAT light, light.x;
            MAD light, light, -program.env[3], program.env[3];
        ]])

        @combine

        END
    ]
]
alias: worldshader = [
    shader (if (< (strstr $arg1 "env") 0) 0 2) $arg1 [
        @vpstart
        DP3 result.texcoord[0].x, opos, program.env[0];
        DP3 result.texcoord[0].y, opos, program.env[1];
        DP3 result.texcoord[1].x, state.matrix.texture[1].row[0], vertex.texcoord[1];
        DP3 result.texcoord[1].y, state.matrix.texture[1].row[1], vertex.texcoord[1];

        @arg2

        #pragma CUBE2_shadowmap
        #pragma CUBE2_dynlight
        @fogcoord
        END
    ] [
        @fpstart
        OPTION ARB_fog_linear;
        TEMP diffuse, lm;
        TEX diffuse, fragment.texcoord[0], texture[0], 2D;
        TEX lm,      fragment.texcoord[1], texture[1], 2D;

        #pragma CUBE2_shadowmap lm
        #pragma CUBE2_dynlight lm

        @arg3

        MUL diffuse, diffuse, 2;
        @(if (< $numargs 4) [result [MUL result.color, diffuse, lm;]] [result $arg4])

        #pragma CUBE2_water

        END
    ]
]
alias: x = [2]
alias: y = [2]
alias: z = [7]
alias: zfov = [120]
